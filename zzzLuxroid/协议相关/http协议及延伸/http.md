发展史
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP

http0.9 只有get 没有请求头，没有响应头没有状态码，出现错误返回一直错误的html供用户查看
http1.0 构建扩展性，引入http头，和一些其他的状态码信息，基本可用
http1.1 标准化的协议
改进：
keep-alive(pipeline)


http1.0
https://developer.mozilla.org/zh-CN/docs/Web/HTTP

http协议mdn文档

传统的客户端-服务端模型

特性：
1.无状态协议
服务器不会在第一个请求和第二个请求之间保留状态和记录数据

2.无连接
不会保持长时间连接，处理完数据后即断开，后在keep-alive(管线化)和http2.0中就基本没有了

3.明文传输(文本协议)(https解决)

http使用80端口

http1.1

新特性：
新增了keep-alive,管道化技术，keep-alive顾名思义就是在一个TCP连接上可以发送多个http请求
keep-alive:
优点：可以在一个TCP连接上发送多个http请求
缺点：还是和http一样第二个请求发送必须等待第一个请求的响应
keep-alive的pipeLine技术
优点：第二个请求发送可以不用等待第一个请求的响应，但是要求服务端的响应必须按照顺序返回
缺点：当第一个任务处理时候过长时，仍有队头阻塞问题

http1.0原有缓存字段
expires：强缓存 绝对时间 Expires: Wed, 21 Oct 2015 07:28:00 GMT 一个http时间戳，即在此时候之后，响应过期。
Last-Modified：协商缓存 配套字段 if-Modified-Since，后者是客户端带着时间去服务端验证Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
http1.1新增了几个缓存字段
Cache-Control:强缓存
Cache-Control:max-age=<seconds> 单位为秒，相对时间
点：no-cache:强制每个请求都去走协商缓存流程
no-sotre:不使用任何缓存

ETag: W/"<etag_value>"Etag类似于指纹，hash值 协商缓存 If-None-Match

除开协议版本区别
为什么Cache-Control的优先级>expires的优先级
expires是绝对时间，要求客户端和服务端的时间严格同步，但是客户端时间是可以被修改的所以并不可靠
为什么ETag的优先级>Last-Modified的优先级

一些文件也许会周期性的更改,但是他的内容并不改变(仅仅改变的修改时间),这个时候,我们并不希望客户端认为这个文件被修改了,而重新 get
某些文件修改非常频繁,比如在秒以下的时间内进行修改(比方说 1s 内修改了 N 次),If-Modified-Since能检查到的粒度时 s 级的,这种修改无法判断(或者说 UNIX 记录 MTIME只能精确到秒)
某些服务器不能精确得到的文件的最后修改时间


强缓存流程略过，协商缓存第一次200，第二次带上协商缓存字段判断304or200

http2.0
HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。
实现低延迟高吞吐量。对于前端开发者而言，减少了优化工作。
本文将重点围绕以下几点新特性的作用、工作过程以及如何更出色的完成了优化工作来介绍HTTP2.0

二进制分帧层 (Binary Framing Layer)
首部压缩
流量控制
多路复用
请求优先级
服务器推送 (websocket)


二进制分帧层 
在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。
术语
    帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。
    流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符
在二进制分帧层上，HTTP2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装。其中，HTTP1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。
首部压缩
    客户端,服务端都缓存一份头表用于下次用hash的方式取出使用
    使用hpack算法
    它使用一份索引表来定义常用的 HTTP Header。把常用的 HTTP Header 存放在表里。请求的时候便只需要发送在表里的索引位置即可。
    例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示。 具体这里的静态映射表请看附录的Table 1: Static Table Entries。
    http://www.voidcn.com/article/p-nkoisujb-boo.html

多路复用
    一个tcp连接可以有多个流 流里有多个帧 通过id归类


服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。


主要解决线头阻塞和浏览器连接限制

所以，在 HTTP/1.1 中提出了管道机制（默认不开启），下一次的请求不需要等待上一个响应来之后再发送，但这要求服务端必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 (Head-Of-Line Blocking)

总结一下，HTTP/1.x keep-alive 与 HTTP/2 多路复用区别：

HTTP/1.x 是基于文本的，只能整体去传；HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送

HTTP/1.x keep-alive 必须按照请求发送的顺序返回响应；HTTP/2 多路复用不按序响应

HTTP/1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP/2 同域名下所有通信都在单个连接上完成

HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应 

需要注意的是 http2.0并没有解决队头阻塞问题，它只解决了应用层的阻塞，但是tcp协议层面的阻塞并没有解决，当tcp连接丢包时，应用性能可能会比http1.1更差

概念：队头阻塞
当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 (Head-Of-Line Blocking)

websocket和服务器推送有什么区别？
https://www.zhihu.com/question/32039008?sort=created
websocket可以让服务端和客户端互相交换信息，并且都是两端可以感知的
但是服务端推送具体来说 不是推送给前端而是推送给浏览器，一般是推送一些可缓存的静态资源
http2.0一般只有一个TCP连接，策略虽好，但是遇到频繁丢包的情况，其速度可能不如http1


http3.0
UDP本身是无连接的、没有建链和拆链成本
UDP的数据包无队头阻塞问题
UDP改造成本小

为什么http3.0选择了udp作为传输层
1.要改造tcp历史包袱过重
2.TCP协议栈是Linux内部的重要部分，修改和升级成本很大

综合而知，谷歌决定在UDP基础上改造一个具备TCP协议优点的新协议也就顺理成章了，这个新协议就是QUIC协议。




