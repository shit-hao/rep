https://zhuanlan.zhihu.com/p/495649475

https://web.dev/user-centric-performance-metrics/#types-of-metrics

https://segmentfault.com/a/1190000022233919

https://blog.csdn.net/weixin_43964148/article/details/124089667

https://web.dev/metrics/

远古时代，有2个指标一个是DOMContentLoaded另一个是load事件
对于之前的页面和现代的服务端渲染的页面，这两个指标都可以很好地衡量首屏内容展示时间。但对于现代复杂的单页应用，都是通过JS操作DOM向页面添加主要内容，对于这种场景，DOMContentLoaded和load事件就不能很好地衡量首屏显示时间了。

于是有FP、FCP、FMP被提出来，它们关注的不是“加载”，而是“渲染”，因此能更好地表现用户看到的情况。


FP First Paint 白屏时间 首帧 首帧fp
https://developer.mozilla.org/zh-CN/docs/Glossary/First_paint

First Paint，是Paint Timing API的一部分，是页面导航与浏览器将该网页的第一个像素渲染到屏幕上所用的中间时，渲染是任何与输入网页导航前的屏幕上的内容不同的内容。它回答了“发生了什么？”这个问题。


FCP First Contentful Paint 首屏时间 首屏fcp 首次有内容的绘制，第一个dom元素绘制完成

https://web.dev/fcp/

首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容"指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。

两个重要的指标是first paint (FP) 和first contentful paint (FCP) ，它们之间的区别在于，FP标志着浏览器开始呈现页面，而FCP是浏览器从DOM中呈现第一个内容，发生在用户第一次开始使用页面内容的时候。

您会注意到，虽然部分内容已完成渲染，但并非所有内容都已经完成渲染。这是首次内容绘制 (FCP) 与*Largest Contentful Paint 最大内容绘制 (LCP)*（旨在测量页面的主要内容何时完成加载）之间的重要区别。

FCP 时间1.8s内good 1.8s-3s需要提高 3s以上垃圾

怎样算是良好的 FCP 分数？ #
为了提供良好的用户体验，网站应该努力将首次内容绘制控制在1.8 秒或以内。为了确保您能够在大部分用户的访问期间达成建议目标值，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

如何改进FCP

1.消除阻塞渲染的资源

Lighthouse 报告的 Opportunities 部分列出了阻止第一次绘制页面的所有 URL。目标是通过内联关键资源、延迟非关键资源和删除任何未使用的资源来减少这些渲染阻止 URL 的影响。

Lighthouse标记了两种类型的渲染阻止 URL：脚本和样式表。

一个<script>标签：

1.是在<head>文档中。
2.没有defer属性。
3.没有async属性。
一个<link rel="stylesheet">标签：

1.没有disabled属性。当此属性存在时，浏览器不会下载样式表。
2.没有media专门匹配用户设备的属性。media="all"被认为是渲染阻塞。

Chrome浏览器more-tools -> Coverage 可以看这个页面加载的js和css的使用情况
红色->未利用 蓝色->已利用

绿色（关键）：第一次绘制所需的样式；对页面核心功能至关重要的代码。
红色（非关键​​）：适用于不立即可见的内容的样式；代码未在页面的核心功能中使用。

如何消除渲染阻塞脚本#
确定关键代码后，将该代码从阻止呈现的 URL 移动到scriptHTML 页面中的内联标记。当页面加载时，它将拥有处理页面核心功能所需的东西。

如果阻止呈现的 URL 中有不重要的代码，您可以将其保留在 URL 中，然后使用async或defer属性标记 URL（另请参阅使用 JavaScript 添加交互性）。

应该删除根本不使用的代码（请参阅删除未使用的代码）。


2.缩小 CSS
3.移除未使用的 CSS

4.预连接到所需的来源

<link rel=preconnect>

只要向页面添加链接标签，就可以将您的意图告知浏览器：

<link rel="preconnect" href="https://example.com">

这样一来，浏览器就知道该页面打算连接到 example.com 并从那里检索内容。

请记住，虽然 <link rel="preconnect"> 消耗不大，但它仍然会占用宝贵的 CPU 时间，尤其是在创建安全连接时。如果在 10 秒内没有使用连接，这种情况尤其糟糕，因为浏览器会关闭它，从而浪费所有早期的连接工作。



5.减少服务器响应时间 (TTFB)

https://web.dev/ttfb/

TTFB 是以下请求阶段的总和：

重定向时间
Service Worker 启动时间（如果适用）
DNS 查询
连接和 TLS 协商
请求，直到响应的第一个字节到达

如何提高 TTFB #
改进 TTFB 在很大程度上取决于您的托管服务提供商和后端应用程序堆栈。高 TTFB 值可能是由于以下一个或多个问题造成的：

1.基础设施不足以处理高流量负载的托管服务
2.内存不足可能导致抖动的 Web 服务器
3.未优化的数据库表
4.次优的数据库服务器配置

改善高 TTFB 时间和相关感知延迟的其他机会包括：

1.避免多页重定向。
2.预连接到跨域资源所需的源。
3.将您的来源提交到HSTS 预加载列表以消除 HTTP 到 HTTPS 重定向延迟。
4.使用 HTTP/2或HTTP/3。
5.考虑为尚未指定减少数据使用偏好的用户进行快速页面导航的预测预取。
6.在可能和适当的情况下，使用服务器端生成 (SSG) 而非 SSR 进行标记。


6.避免多个页面重定向


7.预加载关键请求


8.避免巨大的网络负载
删掉无用代码
GZIP
推迟不必须的请求
图片使用webp
jpeg压缩85

9.使用高效的缓存策略服务静态资产

HTTP 缓存可以加快重复访问时的页面加载时间。

当浏览器请求资源时，提供资源的服务器可以告诉浏览器它应该临时存储或缓存资源多长时间。对于该资源的任何后续请求，浏览器使用其本地副本而不是从网络获取它。

10.避免 DOM 过大

大型 DOM 树可能会以多种方式降低页面性能：

1.网络效率和加载性能
大型 DOM 树通常包含许多在用户首次加载页面时不可见的节点，这会增加用户的数据成本和减慢加载速度，但其实并非必要。
通常，仅在需要时才创建 DOM 节点，当不再需要时，应销毁节点。

如果您当前正在传送大型 DOM 树，请尝试加载您的页面并注意显示了哪些节点。也许您可以从最初加载的文档中删除未显示的节点，而仅在发生相关的用户交互（例如，滚动或单击按钮）之后创建这些节点。

如果您在运行时创建 DOM 节点， 子树修改 DOM 更改断点可以帮助您确定创建节点的时间。

如果无法避免使用大型 DOM 树，另一种提高渲染性能的方法是简化 CSS 选择器。有关更多信息，请参阅 Google 的减小样式计算的范围和复杂性。

2.运行时性能
当用户和脚本与页面交互时，浏览器必须不断重新计算节点的位置和样式。大型 DOM 树与复杂的样式规则相结合，会严重减慢渲染速度。

3.内存性能
如果 JavaScript 使用通用查询选择器，例如 document.querySelectorAll('li')，您可能会在不知不觉中存储对大量节点的引用，这可能会严重超出用户设备的内存容量。

11.最小化关键请求深度
12.确保文本在网页字体加载期间保持可见

字体通常是需要一段时间才能加载的大文件。一些浏览器在字体加载之前隐藏文本，导致不可见文本 (FOIT) 闪烁。

如何避免显示不可见的文字#
避免在加载自定义字体时显示不可见文本的最简单方法是临时显示系统字体。通过包含font-display: swap在您的@font-face风格中，您可以在大多数现代浏览器中避免 FOIT：
font-display API指定字体的显示方式。swap告诉浏览器使用该字体的文本应该立即使用系统字体显示。自定义字体准备就绪后，它将替换系统字体。（有关更多信息，请参阅在加载过程中避免隐藏文本。）




13.保持较低的请求数和较小的传输大小



DCL DOMContentLoaded Event

LCP Largest Contentful Paint 最大内容绘制 (LCP)

https://web.dev/lcp/

最大内容绘制 (LCP) 指标会根据页面首次开始加载的时间点来报告可视区域内可见的最大图像或文本块完成渲染的相对时间。

为了提供良好的用户体验，网站应该努力将最大内容绘制控制在2.5 秒或以内。为了确保您能够在大部分用户的访问期间达成建议目标值，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

如何改进 LCP #
LCP 主要受四个因素影响：

1.缓慢的服务器响应速度
2.JavaScript 和 CSS 渲染阻塞
3.资源加载时间
4.客户端渲染

如需深入了解如何改进 LCP，请参阅优化 LCP。有关其他能够改进 LCP 的单个性能技巧的进一步指导，请参阅：

1.使用 PRPL 模式做到即时加载
2.优化关键渲染路径
3.优化您的 CSS
4.优化您的图像
5.优化网页字体
6.优化您的 JavaScript（针对客户端渲染的网站）


L Onload Event

CLS Layout Shift

TTI：Time To Interactive，可交互时间，整个内容渲染完成

什么是 TTI？ #
TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。

TTI 测量的内容#
TTI 衡量一个页面需要多长时间才能完全交互。在以下情况下，页面被认为是完全交互式的：

页面显示有用的内容，由First Contentful Paint衡量，
为大多数可见页面元素注册了事件处理程序，并且
页面在 50 毫秒内响应用户交互。

可以对 TTI 产生特别大影响的一项改进是推迟或删除不必要的 JavaScript 工作。寻找优化 JavaScript的机会。特别是，考虑通过代码拆分和应用 PRPL 模式来减少 JavaScript 负载。优化第三方 JavaScript也会为某些网站带来显着的改进。

这两个诊断审计提供了额外的机会来减少 JavaScript 工作：

最小化主线程工作
减少 JavaScript 执行时间


FMP：First Meaningful Paint，首次有意义的绘制

First Input Delay 首次输入延迟 (FID)

减少第三方代码的影响
减少 JavaScript 执行时间
最小化主线程工作
保持较低的请求数和较小的传输大小


Speed Index 速度指数 (SI)

TTFB：Time To First Byte 是衡量资源请求与响应的第一个字节开始到达之间的时间的度量。

https://web.dev/ttfb/


Total Blocking Time 总阻塞时间 (TBT)

总阻塞时间 (TBT) 是测量加载响应度的重要实验室指标，因为该项指标有助于量化在页面交互性变为可靠前，不可交互程度的严重性，较低的 TBT 有助于确保页面的可用性。

什么是 TBT？ #
总阻塞时间 (TBT) 指标测量First Contentful Paint 首次内容绘制 (FCP)与Time to Interactive 可交互时间 (TTI)之间的总时间，这期间，主线程被阻塞的时间过长，无法作出输入响应。

每当出现长任务（在主线程上运行超过 50 毫秒的任务）时，主线程都被视作"阻塞状态"。我们说主线程处于"阻塞状态"是因为浏览器无法中断正在进行的任务。因此，如果用户在某个长任务运行期间与页面进行交互，那么浏览器必须等到任务完成后才能作出响应。

对于大多数网站来说，您可以通过遵循一些指导原则来避免所有的意外布局偏移：

Cumulative Layout Shift 累积布局偏移 (CLS)
如何改进 CLS
**始终在您的图像和视频元素上包含尺寸属性，或者通过使用CSS 长宽比容器之类的方式预留所需的空间。**这种方法可以确保浏览器能够在加载图像期间在文档中分配正确的空间大小。请注意，您还可以使用unsized-media 功能策略在支持功能策略的浏览器中强制执行此行为。
**除非是对用户交互做出响应，否则切勿在现有内容的上方插入内容。**这样能够确保发生的任何布局偏移都在预期之内。
**首选转换动画，而不是触发布局偏移的属性动画。**动画过渡的目标是提供状态与状态之间的上下文连续性。
如需深入了解如何改进 CLS，请参阅优化 CLS和调试布局偏移。



#PerformanceObserver

总结 

优化白屏 可以从几个大方向上去说

优化白屏其实就是对web性能的几个指标进行
比如FCP TTI之类的
FCP是首次内容渲染吗 然后优化的话，就是
使用preload，dns-prefetch吧
消除阻塞渲染的一些资源吧，比如script标签和styleshheet标签，尽量用async和defer，css标签用媒体查询
缩小和删掉多余的css吧，因为css解析会阻塞渲染
Chrome的话现在是有一个标签可以让你看到你下载的js和css有哪些用了哪些没用的，可以根据这个去做优化

然后关键资源的话用preload做预加载吧

首页尽量不要请求过多的请求

使用缓存

减少dom大小

避免重定向吧
然后图片用webp

预加载关键资源，延迟加载非关键资源，然后还有一个http2的服务端推送也可以利用

动态import可以用上

减少TTFB吧
这个是服务器的维度
这个一般的话就是用dns预加载遇着preconnect去做
