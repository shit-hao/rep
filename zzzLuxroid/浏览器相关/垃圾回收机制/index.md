//前端JS垃圾回收
//https://segmentfault.com/a/1190000018605776
//https://juejin.im/post/5c6bba32f265da2db07382cf


# 垃圾回收
JavaScript 中的内存管理是自动执行的，而且是不可见的。
我们创建基本类型、对象、函数……所有这些都需要内存。

# 前端垃圾回收有一个重要的概念就是可达性
https://juejin.cn/post/6981588276356317214
简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。

什么是垃圾
访问不到的就是垃圾

# 如何清除垃圾
1.垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
2.然后从各个根对象开始遍历，把不是垃圾的节点改成1
3.清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
4.最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收
标记清除算法缺陷 （fisrt）

标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题


2.引用计数(IE)（last）
此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。
引用计数缺陷

该算法有个限制：无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

那接下来我们主要就来看 V8 中对垃圾回收机制的优化
3.分代式垃圾回收
