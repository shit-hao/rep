//前端JS垃圾回收
//https://segmentfault.com/a/1190000018605776
//https://juejin.im/post/5c6bba32f265da2db07382cf


# 垃圾回收
JavaScript 中的内存管理是自动执行的，而且是不可见的。
我们创建基本类型、对象、函数……所有这些都需要内存。

# 前端垃圾回收有一个重要的概念就是可达性
简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。

什么是垃圾
访问不到的就是垃圾

# 如何清除垃圾
1.标记-清除 (现代浏览器)
基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤:

1.垃圾回收器获取根并“标记”(记住)它们。
2.然后它访问并“标记”所有来自它们的引用。
3.然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
4.以此类推，直到有未访问的引用(可以从根访问)为止。
5.除标记的对象外，所有对象都被删除。
标记清除算法缺陷

那些无法从根对象查询到的对象都将被清除
垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。


2.引用计数(IE)
此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。
引用计数缺陷

该算法有个限制：无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
