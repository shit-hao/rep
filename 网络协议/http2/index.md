前言
https://www.jianshu.com/p/e57ca4fec26f


HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。
实现低延迟高吞吐量。对于前端开发者而言，减少了优化工作。
本文将重点围绕以下几点新特性的作用、工作过程以及如何更出色的完成了优化工作来介绍HTTP2.0

二进制分帧层 (Binary Framing Layer)
首部压缩
流量控制
多路复用
请求优先级
服务器推送 (websocket)


二进制分帧层 
在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。
术语
    帧：HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如HTTP首部、负荷、等等。
    消息：比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成
    流：比消息大的通讯单位。是TCP连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符
在二进制分帧层上，HTTP2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装。其中，HTTP1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。
首部压缩
    客户端,服务端都缓存一份头表用于下次用hash的方式取出使用
    使用hpack算法
    它使用一份索引表来定义常用的 HTTP Header。把常用的 HTTP Header 存放在表里。请求的时候便只需要发送在表里的索引位置即可。
    例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示。 具体这里的静态映射表请看附录的Table 1: Static Table Entries。
    http://www.voidcn.com/article/p-nkoisujb-boo.html

多路复用
    一个tcp连接可以有多个流 流里有多个帧 通过id归类


服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。


主要解决线头阻塞和浏览器连接限制

所以，在 HTTP/1.1 中提出了管道机制（默认不开启），下一次的请求不需要等待上一个响应来之后再发送，但这要求服务端必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这就是队头阻塞 (Head-Of-Line Blocking)

总结一下，HTTP/1.x keep-alive 与 HTTP/2 多路复用区别：

HTTP/1.x 是基于文本的，只能整体去传；HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送

HTTP/1.x keep-alive 必须按照请求发送的顺序返回响应；HTTP/2 多路复用不按序响应

HTTP/1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP/2 同域名下所有通信都在单个连接上完成

HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应 

需要注意的是 http2.0并没有解决队头阻塞问题，它只解决了应用层的阻塞，但是tcp协议层面的阻塞并没有解决，当tcp连接丢包时，应用性能可能会比http1.1更差


