Q: 当你是用this.xxx = xxx
发生了什么

Vue初始化过程中调用
new Vue内部调用了一个_init的函数

_init函数 
做了一些初始化配置_uid，_isVue，调用了created相关的2个钩子
合并了一些配置赋值给vm.$option，初始化生命周期，双向绑定等，然后以$mount结尾

$mount是什么

$mount在多个文件中都有定义，带编译器的Vue和不带编译器的Vue

带编译器的版本多了一步主要时使用compileToFunctions编译成render函数然后在调用之前缓存的mount

缓存的mount

Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

mountComponent干了什么

调用了mount相关的两个钩子，主要逻辑是
定义了一个updateComponent函数，该函数用于充当观察者模式中的观察者，当vm发生变化时调用此函数
code：
new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */)

从上面的代码可以看到，mountComponent 核心就是先调用 vm._render 方法先生成模拟 Node，在实例化一个渲染 Watcher，
在它的回调函数中会调用 updateComponent 方法，最终调用 vm._update 更新 DOM。

    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)

  自己的话说一遍

  首先在Vue初始化的时候$mount的时候Vue会定义一个函数叫updateComponent当成了了Watcher的回调函数，
  并且在双向绑定的时候被收集执行Dep.target 这个变量是一个全局的Watcher，代表当前get的那个属性，
  执行Dep.target.depend()，添加依赖，到这里，Watcher和updateComponent建立联系

  updateComponent内部是调用_update方法，这个方法对比是否有老node，然后执行vm.__patch__

  __patch__会把vnode转为真实node,会发生我们常说的dom diff



  https://www.jb51.net/article/107927.htm

  https://blog.csdn.net/ajh99990/article/details/100355011

  详细说说dom diff？
  首页Vue会比较一些属性值，首先会执行sameVnode 比如key是否相同并且tagName是否相同等等，一般vue列表key的作用在这里体现，
  如果被认为是sameVnode的话，就会做尽可能的节点复用，调用patchVnode，如果不是同一个节点，就直接用新的替换旧的
  patchVnode方法
  patchVnode (oldVnode, vnode) {
    const el = vnode.el = oldVnode.el
    let i, oldCh = oldVnode.children, ch = vnode.children
    if (oldVnode === vnode) return
    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {
        api.setTextContent(el, vnode.text)
    }else {
        updateEle(el, vnode, oldVnode)
    	if (oldCh && ch && oldCh !== ch) {
            updateChildren(el, oldCh, ch)
    	}else if (ch){
            createEle(vnode) //create el's children dom
    	}else if (oldCh){
            api.removeChildren(el)
    	}
    }
}

看代码，
如果是同一类型的节点则
1.如果新旧node完全相等，则返回
2.如果他们是文本节点，且文本内容不一样，则替换
3.如果oldVnode有子节点，新的没有，则删除oldVnode的子节点
4.反之一样，如果old没有，新的有，则添加
5.如果两个vnode都有子节点，则开始比较。

如果不是 则完全替换

比较算法：

updateChildren






